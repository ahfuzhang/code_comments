diff --git a/set.go b/set.go
index ffe7b9f..3104bcf 100644
--- a/set.go
+++ b/set.go
@@ -15,8 +15,10 @@ import (
 //
 // Set.WritePrometheus must be called for exporting metrics from the set.
 type Set struct {
-	mu        sync.Mutex
-	a         []*namedMetric
+	mu sync.Mutex
+	// 数组 a， 拥有所有 map 的 value 部分
+	a []*namedMetric
+	// key 是 prometheus 中 meric 的名字，例如 foo{bar="baz"}
 	m         map[string]*namedMetric
 	summaries []*Summary
 
@@ -33,6 +35,7 @@ func NewSet() *Set {
 }
 
 // WritePrometheus writes all the metrics from s to w in Prometheus format.
+// metrics 上报阶段做的事情
 func (s *Set) WritePrometheus(w io.Writer) {
 	// Collect all the metrics in in-memory buffer in order to prevent from long locking due to slow w.
 	var bb bytes.Buffer
@@ -65,6 +68,7 @@ func (s *Set) WritePrometheus(w io.Writer) {
 	if !sort.SliceIsSorted(s.a, lessFunc) {
 		sort.Slice(s.a, lessFunc)
 	}
+	// sa 存放了所有 metrics 的值
 	sa := append([]*namedMetric(nil), s.a...)
 	metricsWriters := s.metricsWriters
 	s.mu.Unlock()
@@ -267,6 +271,7 @@ func (s *Set) GetOrCreatePrometheusHistogramExt(name string, upperBounds []float
 //
 // The returned counter is safe to use from concurrent goroutines.
 func (s *Set) NewCounter(name string) *Counter {
+	// 每个 counter 一定对应着一个堆上的对象
 	c := &Counter{}
 	s.registerMetric(name, c)
 	return c
@@ -360,7 +365,9 @@ func (s *Set) GetOrCreateFloatCounter(name string) *FloatCounter {
 		nm = s.m[name]
 		if nm == nil {
 			nm = nmNew
+			// 写入索引
 			s.m[name] = nm
+			// 也写入数组
 			s.a = append(s.a, nm)
 		}
 		s.mu.Unlock()
@@ -561,6 +568,7 @@ func (s *Set) registerSummaryQuantilesLocked(name string, sm *Summary) {
 	}
 }
 
+// 创建一个 counter 或者别的类型的 metric，并注册到 set 中
 func (s *Set) registerMetric(name string, m metric) {
 	if err := ValidateMetric(name); err != nil {
 		panic(fmt.Errorf("BUG: invalid metric name %q: %s", name, err))
@@ -576,6 +584,7 @@ func (s *Set) registerMetric(name string, m metric) {
 //
 // Panics if the given name was already registered before.
 func (s *Set) mustRegisterLocked(name string, m metric, isAux bool) {
+	// todo: name 是不是应该做规范化处理? 例如对 tag 进行排序之类的。
 	nm, ok := s.m[name]
 	if !ok {
 		nm = &namedMetric{
